<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Effective Python | jsk的个人空间</title>
<link rel="shortcut icon" href="https://jiang849725768.github.io/favicon.ico?v=1625558256650">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://jiang849725768.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="Effective Python | jsk的个人空间 - Atom Feed" href="https://jiang849725768.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-200672446-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-200672446-1');
</script>


    <meta name="description" content="主要记录阅读《Effective Python》一书中发现的对于现阶段我编写代码有帮助的内容。
主要目标
以 Pythontic 方式来编写程序。
第一章
遵循PEP8风格指南
空白


使用空格而不是制表符来表示缩进


每行字符数不超过..." />
    <meta name="keywords" content="python学习" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://jiang849725768.github.io">
  <img class="avatar" src="https://jiang849725768.github.io/images/avatar.png?v=1625558256650" alt="">
  </a>
  <h1 class="site-title">
    jsk的个人空间
  </h1>
  <p class="site-description">
    记录一些杂思
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              Effective Python
            </h2>
            <div class="post-info">
              <span>
                2020-02-12
              </span>
              <span>
                7 min read
              </span>
              
                <a href="https://jiang849725768.github.io/tag/UzX8Vb-hT/" class="post-tag">
                  # python学习
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <p>主要记录阅读《Effective Python》一书中发现的对于现阶段我编写代码有帮助的内容。</p>
<h2 id="主要目标">主要目标</h2>
<p>以 <em>Pythontic</em> 方式来编写程序。</p>
<h2 id="第一章">第一章</h2>
<h3 id="遵循pep8风格指南">遵循PEP8风格指南</h3>
<h4 id="空白">空白</h4>
<ul>
<li>
<p>使用空格而不是制表符来表示缩进</p>
</li>
<li>
<p>每行字符数不超过79</p>
</li>
<li>
<p>多行的长表达式在换行时应多加一层缩进</p>
</li>
<li>
<p>文件中的函数与类用两个空行隔开</p>
</li>
<li>
<p>同一个类中各方法用一个空行隔开</p>
</li>
</ul>
<h4 id="命名">命名</h4>
<ul>
<li>函数、变量、属性：小写字母，单词间下划线连接 ==&gt; <code>lowercase_underscore</code></li>
<li>类与异常：每个单词首字母均大写  ==&gt; <code>CapitalizedWord</code></li>
<li>模块级别的常量应全部采用大写字母拼写 ==&gt; <code>ALL_CAPS</code></li>
<li>类的实例方法的首个参数命名为<code>self</code>，表示该对象自身类方法的首个参数命名为<code>chs</code>，表示该类自身</li>
</ul>
<p>####　表达式和语句</p>
<ul>
<li>采用内联形式的否定词，<code>if a is not b</code>  √  <code>if not a is b</code>  ×</li>
<li>不通过检测长度的办法（<code>if len(somelist) == 0</code>）判断<code>somelist</code>是否为空，采用<code>if not somelist</code>，<code>if somelist</code>判断</li>
<li>不编写单行的if语句、for循环、while循环及except复合语句</li>
<li>始终将import语句放在文件开头</li>
<li>总是使用绝对名称引用模块，<code>from bar import boo</code>  √  <code>import boo</code>  ×</li>
<li>按顺序将import语句分为三个部分：标准库模块，第三方模块，自用模块，每个部分各语句按模块字母排序</li>
</ul>
<h3 id="用辅助函数替代复杂表达式">用辅助函数替代复杂表达式</h3>
<p>代码清晰程度：if/else表达式 &gt; Boolean操作符（or，and)</p>
<p>使用辅助函数代替复杂的表达式</p>
<h3 id="切割序列">切割序列</h3>
<p><code>somlist[-0:]</code>为原列表的一份拷贝</p>
<p>单次切片操作内不要同时指定start、end和stride <code>[start:end:stride​]</code></p>
<h3 id="列表推导">列表推导</h3>
<h4 id="用列表推导取代map和filter">用列表推导取代map和filter</h4>
<pre><code class="language-python">a = [1,2,3,4,5,6,7,8,9,10]

# 计算平方值
# map
squares = map(lambda x: x**2, a)
# list comprehension(列表推导)
squares = [x**2 for x in a]

# 计算偶数平方值
# map, filter
alt = map(lambda x: x**2, filter(lambda x: x % 2 == 0, a))
# list comprehension
even_squares = [x**2 for x in a if x % 2 == 0]
even_squares == list(alt)
</code></pre>
<h4 id="不使用含两个以上表达式的列表推导">不使用含两个以上表达式的列表推导</h4>
<pre><code class="language-python">my_list = [
    [[1,2,3], [4,5,6]],
    # ...
]
# 多表达式
flat = [x for sublist1 in my_lists
        for sublist2 in sublist1
        for x in sublist2]
# for循环
flat = []
for sublist1 in my_lists:
    for sublist2 in my_lists:
        flat.extend(sublist2)
</code></pre>
<h3 id="用生成器表达式改写数据量较大的列表推导">用生成器表达式改写数据量较大的列表推导</h3>
<p>生成器可减少内存消耗，防止因处理大数据量消耗内存造成的程序崩溃</p>
<p>将列表推导的<code>[]</code>改为<code>()</code>即可构成生成器表达式</p>
<p>生成器表达式可相互组合</p>
<pre><code class="language-python"># 列表推导
value = [len(x) for x in open('my_file.txt')]
# 生成器--&gt;使用()包含表达式
it = (len(x) for x in open('my_file.txt'))
# 生成器组合
roots = ((x, x**0.5) for x in it)
</code></pre>
<h3 id="用-enumerate-代替-range">用 enumerate 代替 range</h3>
<p>enumerate 可指定开始下标：</p>
<pre><code class="language-python">for i,value in enumerate(somelist,1)
# i 从1开始
</code></pre>
<h3 id="用-zip-同时遍历两个迭代器">用 zip 同时遍历两个迭代器</h3>
<p>zip 可将两个或两个以上的迭代器封装为生成器</p>
<p><strong>注意事项</strong>：如果输入的迭代器长度不同，zip会在其中一个耗尽时停止，此时可采用<code>zip_longest</code>函数替代</p>
<h2 id="第二章">第二章</h2>
<h3 id="用异常来表示特殊情况而不是none">用异常来表示特殊情况，而不是None</h3>
<p>在作为判断条件时，None、0或者空字符串等都会视为False，所以在特殊情况下抛出异常而非返回None值</p>
<h3 id="使用nonlocal以在闭包里使用外围作用域中变量">使用nonlocal以在闭包里使用外围作用域中变量</h3>
<p>在表达式中引用变量时，python解释器按如下顺序遍历所有域：</p>
<ol>
<li>当前函数的作用域</li>
<li>任何外围作用域（例如包含当前函数的其他函数）</li>
<li>包含当前代码的模块的 作用域（也叫全局作用域）</li>
<li>内置作用域</li>
</ol>
<p>给变量赋值时，如果当前作用域中无此变量，python将此次赋值视为对该变量的定义，新变量作用域即为当前作用域。</p>
<p>在函数中可使用<code>nonlocal</code>表明应在上层作用域中查找该变量。</p>
<p><strong>限制</strong>：<code>nonlocal</code>不能延伸到模块级别。</p>
<pre><code class="language-python">def func_fir(a,b):
    x = True
    def func_sec(y):
        nonlocal x
        return x
</code></pre>
<p>尽量在简单函数内使用<code>nonlocal</code>，当代码复杂时，应将相关状态封装为辅助类。</p>
<h3 id="用生成器改写直接返回列表的函数">用生成器改写直接返回列表的函数</h3>
<p><code>yield</code></p>
<h3 id="迭代注意事项">迭代注意事项</h3>
<ul>
<li>
<p>迭代器只能产生一轮结果，重复迭代无输出但常常不会报错</p>
</li>
<li>
<p>将迭代器传给<code>iter</code>函数，会返回该迭代器，将容器类型对象传给<code>iter</code>函数，每次都会返回一个新的迭代器对象，可用此特性来判别迭代器</p>
</li>
<li>
<p>把<code>__iter__</code>方法实现为生成器即可定义自己的容器类型。</p>
</li>
</ul>
<h3 id="函数参数优化">函数参数优化</h3>
<h4 id="数量可变的位置参数">数量可变的位置参数</h4>
<p>在最后的位置参数前加<code>*</code>以代表任意数量的位置参数</p>
<pre><code class="language-python">def func_one(a, *b):
    return a + sum(b)

#enable
func_one(1)
func_one(1, 2)
func_one(1, 2, 3)
</code></pre>
<p>传入已有列表时在列表前加上<code>*</code> :</p>
<pre><code class="language-python">list_one = [2, 3, 4]
func_one(1, *list)
</code></pre>
<p><strong>注意事项</strong>：</p>
<ul>
<li>变长参数在传给函数时会先转化为元组，传入生成器可能消耗大量内存导致程序崩溃。</li>
<li>在以后为函数添加新的位置参数时，应该使用只能以关键字形式指定的参数来扩展。</li>
</ul>
<h4 id="用none和文档字符串来描述具有动态默认值的参数">用None和文档字符串来描述具有动态默认值的参数</h4>
<p>函数参数的默认值，会在每个模块加载进来时求出，在Python中实现动态默认值的正确做法是把参数默认值设为<code>None</code>，并在文档字符串中将<code>None</code>所对应的实际行为描述出来，编写函数代码时，若该参数值为<code>None</code>，就将其设为实际的默认值</p>
<h3 id="使用只能以关键字形式指定的参数">使用只能以关键字形式指定的参数</h3>
<p>在参数列表中加入<code>*</code>号，标志位置参数在此终结，之后的参数只能以关键字形式指定。</p>
<pre><code class="language-python">def func(a, b, *, x=True, y=False):
    pass

# TypeError
func(1, 2, True, False)

# Enable
func(1, 2)
func(1, 2, x=True)
</code></pre>
<h2 id="第三章">第三章</h2>
<h3 id="尽量用辅助类维护程序的状态">尽量用辅助类维护程序的状态</h3>
<p>避免使用多层嵌套，不要使用包含其他字典的字典</p>
<p>在保存内部数据的字典变得复杂时，应将这些代码拆解为多个辅助类</p>
<h3 id="简单的接口应接受函数而非类的实例">简单的接口应接受函数而非类的实例</h3>
<p><em>未理解此条意思，感觉此条实际上一步步展示如何更好地调用类的实例作为hook函数</em></p>
<p>在类中使用<code>__call__</code>的特殊方法，可使类的实例能够像普通的python函数一样得以调用</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E4%B8%BB%E8%A6%81%E7%9B%AE%E6%A0%87">主要目标</a></li>
<li><a href="#%E7%AC%AC%E4%B8%80%E7%AB%A0">第一章</a>
<ul>
<li><a href="#%E9%81%B5%E5%BE%AApep8%E9%A3%8E%E6%A0%BC%E6%8C%87%E5%8D%97">遵循PEP8风格指南</a>
<ul>
<li><a href="#%E7%A9%BA%E7%99%BD">空白</a></li>
<li><a href="#%E5%91%BD%E5%90%8D">命名</a></li>
</ul>
</li>
<li><a href="#%E7%94%A8%E8%BE%85%E5%8A%A9%E5%87%BD%E6%95%B0%E6%9B%BF%E4%BB%A3%E5%A4%8D%E6%9D%82%E8%A1%A8%E8%BE%BE%E5%BC%8F">用辅助函数替代复杂表达式</a></li>
<li><a href="#%E5%88%87%E5%89%B2%E5%BA%8F%E5%88%97">切割序列</a></li>
<li><a href="#%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC">列表推导</a>
<ul>
<li><a href="#%E7%94%A8%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC%E5%8F%96%E4%BB%A3map%E5%92%8Cfilter">用列表推导取代map和filter</a></li>
<li><a href="#%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%90%AB%E4%B8%A4%E4%B8%AA%E4%BB%A5%E4%B8%8A%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC">不使用含两个以上表达式的列表推导</a></li>
</ul>
</li>
<li><a href="#%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%94%B9%E5%86%99%E6%95%B0%E6%8D%AE%E9%87%8F%E8%BE%83%E5%A4%A7%E7%9A%84%E5%88%97%E8%A1%A8%E6%8E%A8%E5%AF%BC">用生成器表达式改写数据量较大的列表推导</a></li>
<li><a href="#%E7%94%A8-enumerate-%E4%BB%A3%E6%9B%BF-range">用 enumerate 代替 range</a></li>
<li><a href="#%E7%94%A8-zip-%E5%90%8C%E6%97%B6%E9%81%8D%E5%8E%86%E4%B8%A4%E4%B8%AA%E8%BF%AD%E4%BB%A3%E5%99%A8">用 zip 同时遍历两个迭代器</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0">第二章</a>
<ul>
<li><a href="#%E7%94%A8%E5%BC%82%E5%B8%B8%E6%9D%A5%E8%A1%A8%E7%A4%BA%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%E8%80%8C%E4%B8%8D%E6%98%AFnone">用异常来表示特殊情况，而不是None</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8nonlocal%E4%BB%A5%E5%9C%A8%E9%97%AD%E5%8C%85%E9%87%8C%E4%BD%BF%E7%94%A8%E5%A4%96%E5%9B%B4%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%B8%AD%E5%8F%98%E9%87%8F">使用nonlocal以在闭包里使用外围作用域中变量</a></li>
<li><a href="#%E7%94%A8%E7%94%9F%E6%88%90%E5%99%A8%E6%94%B9%E5%86%99%E7%9B%B4%E6%8E%A5%E8%BF%94%E5%9B%9E%E5%88%97%E8%A1%A8%E7%9A%84%E5%87%BD%E6%95%B0">用生成器改写直接返回列表的函数</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">迭代注意事项</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96">函数参数优化</a>
<ul>
<li><a href="#%E6%95%B0%E9%87%8F%E5%8F%AF%E5%8F%98%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0">数量可变的位置参数</a></li>
<li><a href="#%E7%94%A8none%E5%92%8C%E6%96%87%E6%A1%A3%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9D%A5%E6%8F%8F%E8%BF%B0%E5%85%B7%E6%9C%89%E5%8A%A8%E6%80%81%E9%BB%98%E8%AE%A4%E5%80%BC%E7%9A%84%E5%8F%82%E6%95%B0">用None和文档字符串来描述具有动态默认值的参数</a></li>
</ul>
</li>
<li><a href="#%E4%BD%BF%E7%94%A8%E5%8F%AA%E8%83%BD%E4%BB%A5%E5%85%B3%E9%94%AE%E5%AD%97%E5%BD%A2%E5%BC%8F%E6%8C%87%E5%AE%9A%E7%9A%84%E5%8F%82%E6%95%B0">使用只能以关键字形式指定的参数</a></li>
</ul>
</li>
<li><a href="#%E7%AC%AC%E4%B8%89%E7%AB%A0">第三章</a>
<ul>
<li><a href="#%E5%B0%BD%E9%87%8F%E7%94%A8%E8%BE%85%E5%8A%A9%E7%B1%BB%E7%BB%B4%E6%8A%A4%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%8A%B6%E6%80%81">尽量用辅助类维护程序的状态</a></li>
<li><a href="#%E7%AE%80%E5%8D%95%E7%9A%84%E6%8E%A5%E5%8F%A3%E5%BA%94%E6%8E%A5%E5%8F%97%E5%87%BD%E6%95%B0%E8%80%8C%E9%9D%9E%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B">简单的接口应接受函数而非类的实例</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a>
  <a class="rss" href="https://jiang849725768.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
